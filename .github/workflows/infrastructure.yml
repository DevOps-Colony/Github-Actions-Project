name: Infrastructure Deployment

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        default: 'staging'
        type: choice
        options: [ staging, production ]

env:
  AWS_REGION: us-west-2
  TF_VERSION: 1.8.5

jobs:
  determine-environment:
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.set-env.outputs.environment }}
    steps:
      - name: Determine environment
        id: set-env
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
          elif [ "${{ github.ref }}" == "refs/heads/main" ]; then
            echo "environment=production" >> $GITHUB_OUTPUT
          else
            echo "environment=staging" >> $GITHUB_OUTPUT
          fi

  stage-1-aws-infrastructure:
    name: Deploy AWS Infrastructure (Stage 1)
    runs-on: ubuntu-latest
    needs: determine-environment
    environment: ${{ needs.determine-environment.outputs.environment }}
    defaults:
      run:
        working-directory: ./infra/stage-1-aws
    outputs:
      cluster-name: ${{ steps.get-outputs.outputs.cluster_name }}
      ecr-repository-url: ${{ steps.get-outputs.outputs.ecr_repository_url }}
      load-balancer-dns: ${{ steps.get-outputs.outputs.load_balancer_dns }}
      cluster-endpoint: ${{ steps.get-outputs.outputs.cluster_endpoint }}
      cluster-ca: ${{ steps.get-outputs.outputs.cluster_ca }}
      oidc-provider-arn: ${{ steps.get-outputs.outputs.oidc_provider_arn }}
      target-group-arn: ${{ steps.get-outputs.outputs.target_group_arn }}
      rds-endpoint: ${{ steps.get-outputs.outputs.rds_endpoint }}

    steps:
      - uses: actions/checkout@v4
      - uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false
      - uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Terraform Init
        run: |
          terraform init \
            -backend-config="bucket=bankapp-terraform-state-2024" \
            -backend-config="key=stage-1-${{ needs.determine-environment.outputs.environment }}/terraform.tfstate" \
            -backend-config="region=${{ env.AWS_REGION }}" \
            -backend-config="dynamodb_table=terraform-state-lock-${{ needs.determine-environment.outputs.environment }}"

      - name: Import existing resources
        run: |
          # Import in dependency order
          bash ../../.github/scripts/terraform-import/import-eks.sh "bankapp-${{ needs.determine-environment.outputs.environment }}" "${{ env.AWS_REGION }}" "." || true
          bash ../../.github/scripts/terraform-import/import-alb.sh "bankapp-${{ needs.determine-environment.outputs.environment }}-alb" "${{ env.AWS_REGION }}" "." || true
          bash ../../.github/scripts/terraform-import/import-ecr.sh "bankapp-${{ needs.determine-environment.outputs.environment }}" "${{ env.AWS_REGION }}" "." || true
          bash ../../.github/scripts/terraform-import/import-tg.sh "bankapp-${{ needs.determine-environment.outputs.environment }}-tg" "${{ env.AWS_REGION }}" "." || true
          bash ../../.github/scripts/terraform-import/import-iam-role.sh "bankapp-${{ needs.determine-environment.outputs.environment }}-node-group-role" "module.eks.aws_iam_role.node_group" "." || true
          bash ../../.github/scripts/terraform-import/import-rds-subnet-group.sh "bankapp-${{ needs.determine-environment.outputs.environment }}-db-subnet-group" "module.rds.aws_db_subnet_group.main" "." || true

      - name: Handle Resource Conflicts
        run: |
          # Check for state sync issues and refresh
          terraform refresh || true
          
          # If RDS subnet group has VPC conflicts, remove it and let Terraform recreate
          terraform state rm module.rds.aws_db_subnet_group.main || true

      - name: Handle Target Group Dependencies
        run: |
          bash ../../.github/scripts/terraform-cleanup/handle-tg-deletion.sh "${{ needs.determine-environment.outputs.environment }}" "${{ env.AWS_REGION }}" || true

      - name: Terraform Plan & Apply
        run: |
          if ! terraform plan -out=tfplan; then
            # Handle conflicts by targeted cleanup
            terraform destroy -target=aws_lb_listener.app_listener -auto-approve || true
            terraform destroy -target=aws_lb_target_group.app_tg -auto-approve || true
            terraform plan -out=tfplan
          fi
          terraform apply -auto-approve tfplan

      - id: get-outputs
        run: |
          echo "cluster_name=$(terraform output -raw eks_cluster_id || echo '')" >> $GITHUB_OUTPUT
          echo "ecr_repository_url=$(terraform output -raw ecr_repository_url || echo '')" >> $GITHUB_OUTPUT
          echo "load_balancer_dns=$(terraform output -raw load_balancer_dns || echo '')" >> $GITHUB_OUTPUT
          echo "cluster_endpoint=$(terraform output -raw eks_cluster_endpoint || echo '')" >> $GITHUB_OUTPUT
          echo "cluster_ca=$(terraform output -raw eks_cluster_certificate_authority_data || echo '')" >> $GITHUB_OUTPUT
          echo "oidc_provider_arn=$(terraform output -raw eks_oidc_provider_arn || echo '')" >> $GITHUB_OUTPUT
          echo "target_group_arn=$(terraform output -raw target_group_arn || echo '')" >> $GITHUB_OUTPUT
          echo "rds_endpoint=$(terraform output -raw rds_endpoint || echo '')" >> $GITHUB_OUTPUT

  stage-2-kubernetes:
    name: Deploy Kubernetes Resources (Stage 2)
    runs-on: ubuntu-latest
    needs: [determine-environment, stage-1-aws-infrastructure]
    defaults:
      run:
        working-directory: ./infra/stage-2-kubernetes

    steps:
      - uses: actions/checkout@v4
      - uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false
      - uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Wait for EKS cluster
        run: aws eks wait cluster-active --name "${{ needs.stage-1-aws-infrastructure.outputs.cluster-name }}" --region ${{ env.AWS_REGION }}

      - name: Update kubeconfig
        run: aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name "${{ needs.stage-1-aws-infrastructure.outputs.cluster-name }}"

      - name: Create AWS Load Balancer Controller IAM Policy
        run: |
          POLICY_ARN="arn:aws:iam::$(aws sts get-caller-identity --query Account --output text):policy/AWSLoadBalancerControllerIAMPolicy"
          if ! aws iam get-policy --policy-arn "$POLICY_ARN" >/dev/null 2>&1; then
            curl -o iam_policy.json https://raw.githubusercontent.com/kubernetes-sigs/aws-load-balancer-controller/v2.7.2/docs/install/iam_policy.json
            aws iam create-policy --policy-name AWSLoadBalancerControllerIAMPolicy --policy-document file://iam_policy.json
          fi

      - name: Deploy Kubernetes resources
        run: |
          terraform init \
            -backend-config="bucket=bankapp-terraform-state-2024" \
            -backend-config="key=stage-2-${{ needs.determine-environment.outputs.environment }}/terraform.tfstate" \
            -backend-config="region=${{ env.AWS_REGION }}" \
            -backend-config="dynamodb_table=terraform-state-lock-${{ needs.determine-environment.outputs.environment }}"
          
          terraform plan -out=tfplan \
            -var="aws_region=${{ env.AWS_REGION }}" \
            -var="project_name=bankapp" \
            -var="environment=${{ needs.determine-environment.outputs.environment }}" \
            -var="namespace=bankapp-${{ needs.determine-environment.outputs.environment }}" \
            -var="db_password=${{ secrets.DB_PASSWORD }}"
          
          terraform apply -auto-approve tfplan

      - name: Verify Deployment
        run: |
          kubectl get all -n bankapp-${{ needs.determine-environment.outputs.environment }}
          kubectl get ingress -n bankapp-${{ needs.determine-environment.outputs.environment }}
