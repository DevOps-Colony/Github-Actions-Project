name: Infrastructure Deployment

on:
  push:
    branches: [ main, develop ]   # run for any push to main or develop
  pull_request:
    branches: [ main, develop ]   # run on PRs to main or develop
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production

env:
  AWS_REGION: us-west-2
  TF_VERSION: 1.8.5

jobs:
  determine-environment:
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.set-env.outputs.environment }}
    steps:
    - name: Determine environment
      id: set-env
      run: |
        if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
          echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
        elif [ "${{ github.ref }}" == "refs/heads/main" ]; then
          echo "environment=production" >> $GITHUB_OUTPUT
        else
          echo "environment=staging" >> $GITHUB_OUTPUT
        fi

  stage-1-aws-infrastructure:
    name: Deploy AWS Infrastructure (Stage 1)
    runs-on: ubuntu-latest
    needs: determine-environment
    environment: ${{ needs.determine-environment.outputs.environment }}
    
    defaults:
      run:
        working-directory: ./infra/stage-1-aws
    
    outputs:
      cluster-name: ${{ steps.outputs.outputs.cluster_name }}
      ecr-repository-url: ${{ steps.outputs.outputs.ecr_repository_url }}
      load-balancer-dns: ${{ steps.outputs.outputs.load_balancer_dns }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TF_VERSION }}

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Create S3 backend bucket if not exists
      run: |
        BUCKET_NAME="bankapp-terraform-state-2024"
        echo "Checking if bucket $BUCKET_NAME exists..."
        
        if ! aws s3 ls "s3://$BUCKET_NAME" 2>&1 | grep -q 'NoSuchBucket'; then
          echo "Bucket already exists"
        else
          echo "Creating S3 bucket for Terraform state..."
          aws s3 mb s3://$BUCKET_NAME --region ${{ env.AWS_REGION }}
          
          aws s3api put-bucket-versioning \
            --bucket $BUCKET_NAME \
            --versioning-configuration Status=Enabled
          
          aws s3api put-bucket-encryption \
            --bucket $BUCKET_NAME \
            --server-side-encryption-configuration '{
              "Rules": [
                {
                  "ApplyServerSideEncryptionByDefault": {
                    "SSEAlgorithm": "AES256"
                  }
                }
              ]
            }'
        fi

    - name: Create DynamoDB lock table if not exists
      run: |
        LOCK_TABLE_NAME="terraform-state-lock"
        echo "Checking if DynamoDB table $LOCK_TABLE_NAME exists..."
        
        if ! aws dynamodb describe-table --table-name "$LOCK_TABLE_NAME" >/dev/null 2>&1; then
          echo "Creating DynamoDB table for Terraform state lock..."
          aws dynamodb create-table \
            --table-name "$LOCK_TABLE_NAME" \
            --attribute-definitions AttributeName=LockID,AttributeType=S \
            --key-schema AttributeName=LockID,KeyType=HASH \
            --billing-mode PAY_PER_REQUEST
        else
          echo "DynamoDB lock table already exists."
        fi

    - name: Terraform Init (Stage 1)
      run: terraform init

    - name: Import existing ECR repo if it exists
      run: |
        ECR_NAME="bankapp"
        echo "Checking if ECR repo '$ECR_NAME' exists in AWS..."
        if aws ecr describe-repositories --repository-names "$ECR_NAME" --region ${{ env.AWS_REGION }} --query "repositories[0].repositoryName" --output text >/dev/null 2>&1; then
          echo "ECR repo '$ECR_NAME' already exists. Importing into Terraform state..."
          if ! terraform state list | grep -q "aws_ecr_repository.app_repo"; then
            terraform import aws_ecr_repository.app_repo "$ECR_NAME" || echo "Import skipped."
          else
            echo "ECR repo already in Terraform state. Skipping import."
          fi
        else
          echo "ECR repo '$ECR_NAME' does not exist. Terraform will create it."
        fi

    - name: Check & force unlock state Terraform lock
      if: always()
      run: |
        LOCK_TABLE_NAME="terraform-state-lock-${{ needs.determine-environment.outputs.environment }}"
        echo "Checking for stale Terraform locks in DynamoDB table: $LOCK_TABLE_NAME..."

        if aws dynamodb describe-table --table-name "$LOCK_TABLE_NAME" --region ${{ env.AWS_REGION }} >/dev/null 2>&1; then
          ITEM=$(aws dynamodb scan \
            --table-name "$LOCK_TABLE_NAME" \
            --region ${{ env.AWS_REGION }} \
            --query "Items" \
            --output json)

          if [ "$ITEM" != "[]" ]; then
            LOCK_UUID=$(echo "$ITEM" | jq -r '.[0].Info.S | fromjson | .ID')
            echo "Found lock UUID: $LOCK_UUID â€” forcing unlock..."
            terraform force-unlock -force "$LOCK_UUID" || true
          else
            echo "No lock found, continuing..."
          fi
        else
          echo "Lock table does not exist yet. Skipping unlock check."
        fi

    - name: Terraform Plan (Stage 1)
      id: plan
      run: terraform plan -out=tfplan

    - name: Terraform Apply (Stage 1)
      if: steps.plan.outcome == 'success'
      run: terraform apply -auto-approve tfplan

    - name: Get Stage 1 Outputs
      id: outputs
      run: |
        echo "cluster_name=$(terraform output -raw eks_cluster_id)" >> $GITHUB_OUTPUT
        echo "ecr_repository_url=$(terraform output -raw ecr_repository_url)" >> $GITHUB_OUTPUT
        echo "load_balancer_dns=$(terraform output -raw load_balancer_dns)" >> $GITHUB_OUTPUT

  stage-2-kubernetes:
    name: Deploy Kubernetes Resources (Stage 2)
    runs-on: ubuntu-latest
    needs: stage-1-aws-infrastructure
    defaults:
      run:
        working-directory: ./infra/stage-2-kubernetes
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TF_VERSION }}

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Wait for EKS cluster to be active
      run: |
        aws eks wait cluster-active \
          --name ${{ needs.stage-1-aws-infrastructure.outputs.cluster-name }} \
          --region ${{ env.AWS_REGION }}

    - name: Update kubeconfig
      run: aws eks update-kubeconfig \
        --region ${{ env.AWS_REGION }} \
        --name ${{ needs.stage-1-aws-infrastructure.outputs.cluster-name }}

    - name: Create AWS Load Balancer Controller IAM Policy
      run: |
        POLICY_ARN="arn:aws:iam::$(aws sts get-caller-identity --query Account --output text):policy/AWSLoadBalancerControllerIAMPolicy"
        if ! aws iam get-policy --policy-arn "$POLICY_ARN" >/dev/null 2>&1; then
          curl -o iam_policy.json https://raw.githubusercontent.com/kubernetes-sigs/aws-load-balancer-controller/v2.7.2/docs/install/iam_policy.json
          aws iam create-policy \
            --policy-name AWSLoadBalancerControllerIAMPolicy \
            --policy-document file://iam_policy.json
        fi

    - name: Terraform Init (Stage 2)
      run: terraform init

    - name: Terraform Plan (Stage 2)
      run: terraform plan -out=tfplan

    - name: Terraform Apply (Stage 2)
      run: terraform apply -auto-approve tfplan
